# ch4 구현 유형

'''
@머릿속에 있는 알고리즘을 소스코드로 바꾸는 과정
1. 코딩 테스트에서는 구현이 중ㅅ미이 되는 문제가 자주 출제
2. 완전 탐색 : 모든 경우의 수를 주저 없이 다 계산하는 해결 방겁
3. 시뮬레이션 : 문제에서 제시한 알고리즘을 한 단계씩 차례대로 직접 수행

@ 파이썬에서 리스트 크기
1. 리스트를 통해 문제를 풀 때, 메모리 제한을 염두해 두고 코딩하기
2. 리스트 길이           1,000 :  4KB,
                    1,000,000 :  4MB,
                   10,000,000 : 40MB
 - 크기가 1000만 이상인 리스트가 있다면 메모리 용량 제한을 생각해야 한다.
3. 입출력 시간 제한 문제도 고려해야 한다.

@ 채점환경
1. 1초에 2000만 번의 연산을 수행할 경우, 안정적
ex) 시간 제한 1초, 데이터의 개수가 100만 개
    => 시간 복잡도 O(NlogN) 이내의 알고리즘을 이용하여 문제를 풀어야 함
'''


'''
@예제 1) 상하좌우

# 문제
A는 N * N 크기의 정사각형 공간 위에 있다.
이 공간은 1* 1 크기의 정사각형으로 나누어져 있다.
좌상단 좌표는 (1, 1) , 우하단 좌표는 (N, N) 이다.
L : 좌측 한 칸 이동
R : 우측 한 칸 이동
U : 위로 한 칸 이동
D : 아래로 한 카 이동
(1, 1) 에서 시작하여 위의 네가지 명령어에 따라 움직이고 마지막 위치의 좌표를 출력해자

# 입력 조건
1. 첫째 줄 : 공간의 크기  N(1~100)
2. 둘째 줄 : 이동 명령어들 (1~100개)

# input
5
R R R U D D
# output
3 4
'''
# # A의 경로 함수
# def move(M):
#     global r, c
#     if M == 'R' and 1 <= c < N:
#         c += 1
#     elif M == 'L' and 1 < c <= N:
#         c -= 1
#     elif M == 'U' and 1 < r <= N:
#         r -= 1
#     elif M == 'D' and 1 <= r < N:
#         r += 1
#
# N = int(input())
# r = 1
# c = 1
# # M = input().split()
# # print(M)
# for i in input().split():
#     move(i)
# print(r, c)
'''
#리뷰
교재는 이 문제를 delta 탐색으로 풀었다.
하지만, 조건이 까다롭지 않기 때문에 굳이 delta 탐색으로 풀 필요성을 못 느꼈다.
'''


'''
@ 예제 2) 시각 (BOJ 18312)

# 문제
정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서 3이 하나라도 
포함되는 모든 경우의 수를 구하는 프로그램 작성하기.

#입력 조건
1. 첫째 줄에 정수 N이 입력 (0 ~ 23)

#input
5
#output
11475 
'''

# N = int(input())
# # 0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ...
# #       1                      1                             1
# # 1분에 3, 13, 23, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 43, 53  (15개)
# # 1시간에 3  13  23  30  31  32  33  34  35  36  37  38  39  43  53  일때  (60개)
# #      나머지 15개
# #   (60* 15 + 15* 45)
# # 만약 시간이 3 13 23 이면 총 (60*60 개)
# sol = 0
# for i in range(N+1):
#     sol += 105 * 15
#     if i == 3 or i == 13 or i ==23:
#         sol += 60*60 - (105 * 15)
# print(sol)

'''
리뷰
코드는 완전 탐색을 하고 있으나, 이 문제는 특정한 규칙이 있기 때문에 굳이 완전 탐색을 하지
않아도 될 것으로 보인다
'''

'''
# BOJ 18312 시각

k = 0 인 경우
1분에 (15개)
1시간에 (15개) 일때 60
         45개 일때 15개
만약 0, 01, 02, 03, 04, 05, 06, 07, 08, 09, 10, 20 일때 60*60

k < 6 대신 
0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 ...
      1                      1                             1
1분에 3, 13, 23, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 43, 53  (15개)
1시간에 3  13  23  30  31  32  33  34  35  36  37  38  39  43  53  일때  (60개)
     나머지 15개
  (60* 15 + 15* 45)
만약 시간이 3 13 23 이면 총 (60*60 개)

k = 6 인 경우
1분에   6 16 26 36 46 56 (6개)
1시간에 6 16 26 36 46 56 일때, (60개)
      나머지 6개
  (60 * 6 + 6 * 54)
만약 시간이 6 16 이면 총 (60*60 개)
'''
# N, k = map(int, input().split())
# sol = 0
#
# if k < 6:
#     for i in range(N+1):
#         sol += 105 * 15
#         if k == 0:
#             if i < 10:
#                 i = '0' + str(i)
#         if str(k) in str(i):
#             sol += 60*60 - (105 * 15)
# else:
#     for i in range(N+1):
#         sol += 114 * 6
#         if str(k) in str(i):
#             sol += 60*60 - (114 * 6)
# print(sol)
'''
@리뷰
쓸데 없이 수식으로 풀려다가 된통 당했다.. 이 문제는 그냥 무지성 완전탐색이 최고일듯
'''

'''
@ 실전 1) 왕실 나이트

# 문제
체스판 8 * 8
특정 칸에 나이트 서 있음 
L자 형태로 움직임
1. 수평으로 두 칸 이동한 뒤에 수직으로 한 칸 이동 ( c +- 2, r +- 1)
2. 수직으로 두 칸 이동한 뒤에 수평으로 한 칸 이동 ( c +- 1, r +- 2)
나이트 위치가 주어 졌을 때, 나이트가 움직일 수 있는 경우에 수는?
수평은 a~h
수직은 1~8

# 입력조건
첫째 줄 : 나이트의 현재 위치 문자 + 숫자 로 주어짐 ex( a1)
'''

# lst = ['-1', 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h']
#
# C = input().strip()
# chk = [(2,1), (2,-1), (-2,1),(-2,-1),(1,2),(1,-2), (-1,2), (-1, -2)]
# cnt = 0
# for i in chk:
#     c = lst.index(C[0])
#     r = int(C[1])
#     r += i[0]
#     c += i[1]
#     if 1 <= r <= 8 and 1 <= c <= 8:
#         cnt += 1
# print(cnt)
'''
#리뷰
책에 나와있는 풀이와 크게 다르지 않았다.
조금 다른 점은 책은 아스키 코드를 사용하여 문자를 숫자로 변환하였고, 
나는 리스트를 만들어 문자를 숫자로 변환하였다.
'''

'''
@ 실전 2) 게임 개발

# 문제
N * M 정사각형 안 육지나 바다가 생성되어 있음
캐릭터는 동서남북 중 한 곳을 바라봄
(A,B)를 입력 받는데 A는 북쪽으로부터 떨어진 칸의 개수 , B는 서쪽으로부터 떨어진 칸의 개수
캐릭터는 상하 좌우로 움직일 수 있으며, 바다는 갈 수 없다
1. 현재 위치에서 현재 방향을 기준으로 반시계 방향으로 90도 회전하여 시작
2. 캐릭터의 바로 왼쪽 방향에 아직 방문하지 않은 칸이 있으면, 왼쪽으로 회전해서 전진
   없다면 회전만 하고 전진 x
3. 네 방향 모두 갔거나 바다로 되어 있는 칸이 나오면 뒤로 한 칸
   민약, 뒤가 바다인 경우 정지
캐릭터가 방문한 카나의 수를 출력

# 입력조건
첫째 줄 : N, M : N * M 칸 
둘째 줄 : 캐릭터 좌표 A, B 와 방향 d (0,1,2,3 : 북,동,남,서)
셋째 줄~ : 육지인지 바다인지에 대한 정보 (0,1 : 육지, 바다

# input
4 4
1 1 0
1 1 1 1
1 0 0 1
1 1 0 1
1 1 1 1
# output
3
'''

# def chk (r, c):
#     cnt = 0
#     for i in range(4):
#         rr = r + dr[i]
#         cc = c + dc[i]
#         if map1[rr][cc] == 0:
#             cnt += 1
#     return cnt
#
# N, M = map(int,input().split())
# r, c, d = map(int,input().split())
# map1 = [list(map(int,input().split())) for _ in range(N)]
#
# dr = [-1, 0, 1, 0]              # 북 동 남 서
# dc = [ 0,-1, 0, 1]
# map1[r][c] = 1          # 방문 표시
# cnt = 1
# stack = []
# while 1:
#     check = chk(r,c)
#     if check > 1:            # 갈림길이면 스택에 쌓기
#         stack.append((r,c))
#     elif check == 0:
#         if stack:
#             r,c = stack.pop()
#         else:
#             break
#     i = 0
#     while i < 4:                    # 네 방향 모두 갈 수 없으면 다시
#         rr = r + dr[d]              # 90도씩 반시계 방향 회전
#         cc = c + dc[d]
#         if map1[rr][cc] == 0:       # 육지면 전진
#             r = rr
#             c = cc
#             cnt += 1
#             map1[r][c] = 1  # 방문 표시
#             break
#         d = (d + 1) % 4             # 길이 없으면 90도 반시계방향 회전
#         i += 1
# print(cnt)


