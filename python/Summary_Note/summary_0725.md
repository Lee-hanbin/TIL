# Python

## 1. 데이터 구조 (Data)

##### (1) 순서가 있는 데이터 구조

- 문자열(Strigng)

- 리스트(List)

- 튜플(tuple)

##### (2) 순서가 없는 구조

- 셋(Set)

- 딕셔너리(Dictionary)

##### (3) 얕은 복사와 깊은 복사

- 할당

- 얕은 복사

- 깊은 복사

---

## 1. 순서가 있는 데이터 구조

### (1) 문자열

- 모든 문자는 str타입(변경 불가능한 **immutable**)

- **문자열 조회/탐색 메서드**
  
  - `s.find(x)`: x의 첫 번째 위치를 반환. 없으면 **-1 반환**
  
  - `s.index(x)` :x의 첫 번째 위치를 반환. 없으면 **오류 발생**

- **문자열 관련 검증 메서드**
  
  - `s.isalpah()` : 알파벳 문자 여부 (유니코드 상 Letter)
    
    - 한국어 포함!
  
  - `s.isupper()` : 대문자 여부
  
  - `s.islower()` : 소문자 여부
  
  - `s.istitle()` : 타이틀 형식 여부
  
  - `isdeciaml < .isdigit() < .isnumeric` : 숫자 여부

- **문자열 변경 메서드**
  
  - `s.replace(old, new [, count] )`: old문자를 new문자로 바꿔서 반환
  
  - `s.strip( [chars] )` : 공백이나 특정 문자를 제거
    
    -  chars가 구분자가 됨
    
    - s.lstrip : 왼쪽 제거
    
    - s.rstrip : 오른쪽 제거
  
  - `s.split( sep = None, maxsplit= -1 )` : 공백이나  특정 문자를 기준으로 분리
  
  - `'sep'.join([iterable])` : 구분자로 iterable을 합침  
    
    - 문자열을 list로 만들기 용이
  
  - `s.upper()` : 모두 대문자로 변경
  
  - `s.lower()` : 모두 소문자로 변경
  
  - `s.swapcase()` : 대문자를 소문자로 , 소문자를 대문자로 변경

- 문자열이 immutable인데, 문자열 변경이 되는 이유
  
  - 기존의 문자열을 변경하는 게 아니라, 변경된 문자열을 새롭게 만들어서 반환



### (2) 리스트

- 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용

- **리스트 메서드**
  
  - `L.append(x)` : 리스트 마지막에 항목 x 추가
  
  - `L.insert(i,x)` : 리스트 인덱스 i에 x를 삽입
  
  - `L.remove(x)` : 리스트에서 처음 나타나는 x를 제거 
    
    - x가 존재하지 않으면 **ValueError** 발생
  
  - `L.pop()` : 리스트의 마지막 항목을 반환 후, 제거
    
    ex) a = L.pop()
  
  - `L.pop(i)` : 리스트의 인덱스 i에 있는 항목을 반환 후 제거
  
  - `L.extend(m)` :순회형 m의 모든 항목들의 리스트 끝에 항목을 반환 후 제거
    
    -  m에 문자열 넣으면 해당 문자 하나씩 list에 추가
  
  - `L.index(x [, start, end] )` : 리스트에서 처음 나타나는 x의 인덱스를 반환
    
    - start ~ end 에서 가장 먼저 나타나는 x의 인덱스를 반환
  
  - `L.reverse()` : 리스트를 거꾸로 정렬
  
  - `L.sort()` : 리스트를 정렬 (매개변수 이용가능)
    
    - None 반환. List 자체를 정렬하는 것
    
    - `sorted(L)` 은 다른 곳에 정렬해서 저장해줌
  
  - `L.count(x)` : 리스트에 x가 몇 개?
  
  - `L.clear()` : 리스트 초기화



### (3) 튜플

- 여러 개의 값을 순서가 있는 구조로 저장하고 싶을 때 사용
  
  cf) 리스트와 다르게 생성 후, 담고 있는 값 변경이 불가

- 리스트의 메서드 중 값 자체에 영향을 미치지 않는 메서드만을 지원
  
  

### (4) 연산자 (Operator)

- **멤버십 연산자**
  
  - `in`을 통해 특정 요소가 속해 있는지 여부를 확인
    
    ex) `'a' in 'apple`  `# True`
  
  - `not in` 을 통해 불 포함 요소가 있는지 여부를 확인
    
    ex) `'b' not in 'apple'`  `# True`

- **시퀀스형 연산자**
  
  - 산술연산자(+)
    
    - 시퀀스 간의 concatenation(연결/연쇄)
      
      ex) `[1, 2] + ['a']` : `#[1, 2, '1']`
      
      ex) `(1, 2) + ('a')` : `#(1, 2, 'a')`
  
  - 반복연산자(*)
    
    - 시퀀스를 반복
      
      ex) `[0] * 3` : `#[0, 0, 0]`
      
      ex) `'hi' * 3` : `#'hihihi'`
  
  - range는 불가능



## 2. 비시퀀스형 데이터 구조

### (1) Set

- 중복되는 요소가 없이, 순서에 상관없는 데이터들의 묶음
  
  - 순서가 없기 때문에 인덱스를 이용한 접근 불가

- 담고 있는 요소를 삽입 변경, 삭제 가능 
  
  - 가변 자료형 (mutable)

- **셋 메서드**
  
  - `s.copy()` : 셋의 얕은 복사본을 반환
  
  - `s.add(x)` : 항목 x가 셋 s에 없다면 추가
  
  - `s.pop()` : 셋 s에서 `나`다 싶은 요소가 나감
    
    - set이 비어 있을 경우, **KeyError**
  
  - `s.remove(x)`: 항목 x를 셋 s에서 삭제
    
    - 항목이 존재하지 않을 경우, **KeyError**
  
  - `s.discard(x)` : 항목 x를 셋 s에서 삭제
    
    - 항목이 존재하지 않더라도 에러 발생 x
  
  - `s1.update(s2)` : 셋 s2에 있는 모든 항목 중 셋 s에 없는 항목을 추가
    
    ex) `s.update(*others)` : 여러 값 추가 가능
    
    ex) `s.updtate('a', 'b')`  =  `s.update(['a', 'b'])`
  
  - `s.clear()` : s의 모든 항목을 제거
  
  - `s1. isdisjoint(s2)` : s1과 s2가 서로소 이면 True
  
  - `s1.issubset(S2)` : s1이 s2의 부분집합인 경우 True
  
  - `s1.issuperset(s2)` : s2가 s1의 부분집합인 경우 True



### (2) dictionary

- key-value 쌍으로 이뤄진 자료형
  
  - Key는 변경이 불가능한 데이터만 활용 가능
    
    - string, integer, float, boolean, tuple, range
  
  - value는 형태에 무관하게 가능

- **딕셔너리 메서드**
  
  - `d.clear()` : 모든 항목을 제거
  
  - `d.copy()` : 딕셔너리 d의 얕은 복사본을 반환
  
  - `d.keys()` : 딕셔너리 d의 모든 키를 담은 뷰를 반환
  
  - `d.values()` : 딕셔너리 d의 모든 값을 담은 뷰를 반환
  
  - `d.items()` : 딕셔너리 d의 ahems 키-값의 쌍을 담은 뷰를 반환 
  
  - `d.get()` : 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 None을 반환
  
  - `d.get(k, v)` : 키 k의 값을 반환하는데, 키 k가 딕셔너리 d에 없을 경우 v를 반환
  
  - `d. pop(k)` : 키 k의 값을 반환하고 키 k인 항목을 딕셔너리 d에서 삭제
    
    - 키 k가 딕셔너리 d에 없을 경우 **KeyError**를 발생
  
  - `d.pop(k,v)` 
    
    - 키 k가 딕셔너리 d에 없을 경우 **v**를 반환
  
  - `d.update([other])` : 딕셔너리 d의 값을 매핑하여 업데이트
    
    ex) ` d ={'key' : 'value' }` : 생성
    
    ex)  `d.update(key = 'value')` : key에 해당하는 value값을 수정
  
  - `d.setdefault(key [, default])`
    
    -  key 값이 있으면 value 반환 없으면 default를 value로 해서 추가



## 얕은 복사와 깊은 복사

### (1) 할당

- 대입연산자(=)
  
  - 해당 객체에 대한 객체 참조를 복사
  
  - 즉, 객체가 담긴 **주소 자체를 복사**

### (2) 얕은 복사

- 같은 구성을 하고 있지만, 해당 형태를 복사하여 **새로운 주소에 저장**

- slice 연산자 `b = a[:]`를 활용

- **주의사항**
  
  -  복사하는 리스트의 원소가 주소를 참조하는 경우
    
    ex) `a = [1, 2, [4, ,5 ,6]]`인 경우 `b = a[:]`하더라도 `a[2]`의 요소는 주소 자체로 참조되어 있기 때문에 할당된 것으로 본다.

### (3) 깊은 복사

```python
import copy
a = [1, 2, [4, 5, 6]]
b = copy.deepcopy(a)
=> b는 a의 모든 요소를 복사하여 새로운 주소에 저장한다.
```


