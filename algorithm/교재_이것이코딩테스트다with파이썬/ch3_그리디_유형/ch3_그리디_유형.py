# ch3 그리디 유형

'''
@당장 좋은 것만 선택하는 그리디

1. 단순하지만 강력한 문제 해결 방법
2. 지금 당장 좋은 것만 고르는 방법
3. 현재의 선택이 나중에 미칠 영향에 대해서는 고려 x
4. 사전에 유형을 알지 못해도 풀 수 있는 문제의 유형
5. 경험으로서 감을 익히는 것이 중요

@그리디 접근법은 정확한 답을 찾을 수 있다는 보장이 있을 때, 매우 효과적이다.

1. 문제를 푸는 방향성이 정해져 있는 경우
  => 큰 것부터 작은것 , 큰 수부터 작은 수 .. 등등 규칙이 있는 경우

막약, 아래 거스름돈 문제에 동전의 개수에 대한 다른 조건이 있다면 그리디 접근법은 옳지 않을 수도 있다.
'''

'''
#1. 거스름돈 문제 (BOJ 5585번, BOJ 14916)

손님에게 거스름돈을 돌려줘야 한다.
내가 가지고 있는 동전은 500원 100원 50원 10원 이고, 거슬러 줘야할 동은 N원이다.
N원은 항상 10의 배수
'''

# N = int(input())
# lst = [500,100,50,10]
# lst_cnt = []
# for i in lst:                       # 가장 큰 화폐부터 하나씩 체크
#     if N // i > 0:
#         lst_cnt.append(N//i)        # 최대 화폐 개수를 cnt
#         print(f'{i} : {N//i}')
#         N = N - i * (N//i)          # 남은 잔액 계산

#BOJ_5585_bronze2-거스름돈
# N = int(input())
# N = 1000 - N
# lst = [500,100,50,10,5,1]
# lst_cnt = []
# for i in lst:                       # 가장 큰 화폐부터 하나씩 체크
#     if N // i > 0:
#         lst_cnt.append(N//i)        # 최대 화폐 개수를 cnt
#         N = N - i * (N//i)          # 남은 잔액 계산
# print(sum(lst_cnt))

#BOJ_14916_silver5-거스름돈
# N = int(input())
# N5 = N // 5                   # 거스름돈에서 최대 가능 5원 개수
# N2 = (N - 5 * N5)//2          # 남은 잔액에서 가능한 최대 2원 개수
# while 1:
#     lst_cnt = []
#     if N5 == -1:              # 거스름돈을 5원과 2원으로 불가능하면 -1
#         cnt = -1
#         break
#     if N5 * 5 + N2 * 2 == N:  # 딱 맞아 떨어지면 개수 출력하고 ㅌㅌ
#         cnt = N5 + N2
#         break
#     else:
#         N5 -= 1               # 딱 맞아 떨어지지 않으면 5원의 개수를 하나 줄이고
#         N2 = (N - 5 * N5)//2  # 잔액에 따른 2원의 최대 개수
# print(cnt)

'''
#2. 큰 수의 법칙
다양한 수로 이루어진 배열이 있을 때, 주어진 수들을 M번 더하여 가장 큰 수를 만들기

ex) 2, 4, 5, 4, 6 이 주어졌을 때, M = 8, K = 3이면
    5개의 숫자 중에 중복을 최대 3번 하여 M개를 뽑아 최대값을 구하기

@입력조건
- 첫째 줄 : N (2 ~ 1000), M ( 1 ~ 10000), K (1 ~ 10000) (K<=M)
- 둘째 줄 : N개의 자연수가 주어짐 (공백으로 구분) 

@입력
5 8 3
2 4 5 4 6  

@출력
46
'''

# N, M, K = map(int, input().split())
# lst = list(map(int,input().split()))
# sol = 0
# cnt = 0
# lst.sort(reverse=True)                  # 내림차순 정렬
# for i in range(M):                      # M번 반복
#     cnt += 1                            # 큰 수 카운팅
#     if cnt < K:                         # 가장 큰 수를 K 번 더해준다/
#         sol += lst[0]
#     else:                               # 가장 큰 수를 K 번 더해줬으면 두번째 큰 수를 1번 더해주고 카운팅 초기화
#         sol += lst[1]
#         cnt = 0
# print(sol)

'''
#3. 숫자 카드 게임
여러가지 숫자 카드 중에서 가장 놓은 숫자가 쓰인 카드 한 장을 뽑는 게임

@규칙
1. 숫자가 쓰인 카드들은 N*M형태로 놓여 있음
2. 먼저 뽑고자 하는 카드가 포함되어 있는 행 선택
3. 행에 포함된 카드들 중 가장 낮은 숫자 카드 뽑기
4. 최종적으로 가장 높은 숫자의 카드를 뽑을 수 있도록 전략 세우기 

@input1         @input2
3 3             2 4
3 1 2           7 3 1 8
4 1 4           3 3 3 4
2 2 2

@output1        @output2
2               3

'''

# N, M = map(int, input().split())
# lst = [list(map(int,input().split())) for _ in range(N)]
# lst2 = []
# for i in range(N):              # 각 행에서 가장 작은 숫자 뽑기
#     lst2.append(min(lst[i]))
# print(max(lst2))                # 그 중에서 가장 큰 수 뽑기


'''
#4. 1이 될 때 까지

N이 1이 될 때까지 다음 두 과정 중 하나를 반복적으로 선택하여 수행
1. N - 1
2. N / K    <---- N이 K로 나누어 떨어질 경우에만

@입력조건
첫째 줄에 N(2~100000), K(2~100000) 가 공백으로 구분되며 자연수로 주어짐 N >= K

@input   
25 5
@output
2
'''

# N, K = map(int, input().split())
# cnt = 0
# while N > 1:                    # N이 1이면 빠져나와
#     cnt += 1
#     if N % K == 0:              # N이 K로 나누어 떨어지면
#         N = N // 5              # 두번째 연산
#     else:                       # 아니면
#         N -= 1                  # -1
# print(cnt)
