# ch 5 DFS/BFS

'''
@ 탐색
 - 많은 양의 데이터 중에서 원하는 데이터를 찾는 과정
 - DFS와 BFS를 활용
 - DFS : 스택이용
   BFS :   큐이용

@ 자료구조
 - 데이터를 표현하고 관리하고 처리하기 위한 구조

@ 스택
 - 박스 쌓기
 - 선입후출 or 후입선출

@ 큐
 - 놀이공원의 줄
 - 선입선출
 - from collections import deque 활용
 - 코딩테스트에서 허용되니까 마음껏 사용해도 된다.

@ 재귀 함수
 - DFS와 BFS를 구현하는데 필수적인 이론
 - 자기 자신을 다시 호출하는 함수
 - RecursionError: maximum recursion depth exceeded while pickling an object
   => 재귀의 최대 깊이를 초과

@ 재귀 함수 종료 조건
 - 재귀 함수 문제 풀이에서는 재귀 함수가 언제 끝날지 종료 조건을 꼭 명시!
 - 보통 재귀 함수 초반에 나오는 if문이 종료 조건이다.

@ DFS
 - 깊이 우선 탐색
 - 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘
1. 인접 행렬 방식
 - 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식.
2. 인접 리스트 방식
 - 특정한 노드와 연결된 모든 인접 노드를 순회해야 하는 경우, 인접 행렬 방식에 비해
  메모리 공간의 낭비가 크다.
3. 방법
 - 탐색 시작 노드를 스택에 삽입하고 방문 처리
 - 스택의 최상단 노드에 방문하지 않은 인접 노드가 있으면 그 인접 노드를 스택에 넣고
  방문 처리, 방문하지 않은 인접 노드가 없으면 스택에서 최상단 노드 꺼내기
 - 위의 과정을 반복
Tip
 - 코딩 테스트에서는 번호가 낮은 순서부터 처리하도록 명시하는 경우가 종종 있음.
  따라서 번호가 낮은 순서부터 구현하도록 연습하자.

ex)
def dfs(graph, v, vsited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8],
    [1, 7],
]

# 각 노드가 방문된 정보를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9

# 정의된 DFS 함수 호출
dfs(graph, 1, visited)

'''





















